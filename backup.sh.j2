#!/bin/bash
# Automated Backup Script
# Managed by Ansible - Do not edit manually

set -euo pipefail

# Configuration
APP_NAME="{{ app_name }}"
BACKUP_BASE="{{ backup_base_path }}"
TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
BACKUP_DIR="${BACKUP_BASE}/${TIMESTAMP}"
DB_NAME="{{ db_name }}"
DB_USER="{{ db_user }}"
DB_CONTAINER="${APP_NAME}_db"
APP_CONTAINER="${APP_NAME}_app"
COMPRESSION="{{ backup_compression | lower }}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1" >&2
}

warning() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1"
}

# Start backup process
log "=========================================="
log "Starting backup process"
log "Backup directory: ${BACKUP_DIR}"
log "=========================================="

# Create backup directory structure
mkdir -p "${BACKUP_DIR}"/{volumes,database,configs}

# Record backup start time
BACKUP_START=$(date +%s)

# 1. Backup Docker volumes
log "Backing up Docker volumes..."
VOLUME_START=$(date +%s)

# Backup database volume
if docker volume inspect "${APP_NAME}_db_data" &>/dev/null; then
    log "Backing up database volume..."
    docker run --rm \
        -v "${APP_NAME}_db_data:/source:ro" \
        -v "${BACKUP_DIR}/volumes:/backup" \
        alpine \
        tar czf /backup/db_data.tar.gz -C /source .
    log "Database volume backed up: $(du -h ${BACKUP_DIR}/volumes/db_data.tar.gz | cut -f1)"
else
    warning "Database volume not found"
fi

# Backup application volume
if docker volume inspect "${APP_NAME}_app_data" &>/dev/null; then
    log "Backing up application volume..."
    docker run --rm \
        -v "${APP_NAME}_app_data:/source:ro" \
        -v "${BACKUP_DIR}/volumes:/backup" \
        alpine \
        tar czf /backup/app_data.tar.gz -C /source .
    log "Application volume backed up: $(du -h ${BACKUP_DIR}/volumes/app_data.tar.gz | cut -f1)"
else
    warning "Application volume not found"
fi

VOLUME_END=$(date +%s)
VOLUME_TIME=$((VOLUME_END - VOLUME_START))
log "Volume backup completed in ${VOLUME_TIME} seconds"

# 2. Backup PostgreSQL database
log "Backing up PostgreSQL database..."
DB_START=$(date +%s)

if docker ps --format '{{.Names}}' | grep -q "^${DB_CONTAINER}$"; then
    # Create SQL dump
    docker exec "${DB_CONTAINER}" pg_dump -U "${DB_USER}" -d "${DB_NAME}" \
        > "${BACKUP_DIR}/database/${DB_NAME}.sql"
    
    # Compress if enabled
    if [ "${COMPRESSION}" = "true" ]; then
        gzip "${BACKUP_DIR}/database/${DB_NAME}.sql"
        log "Database dump created and compressed: $(du -h ${BACKUP_DIR}/database/${DB_NAME}.sql.gz | cut -f1)"
    else
        log "Database dump created: $(du -h ${BACKUP_DIR}/database/${DB_NAME}.sql | cut -f1)"
    fi
    
    # Also backup database schema separately
    docker exec "${DB_CONTAINER}" pg_dump -U "${DB_USER}" -d "${DB_NAME}" --schema-only \
        > "${BACKUP_DIR}/database/${DB_NAME}_schema.sql"
    
    # Get row counts for verification
    docker exec "${DB_CONTAINER}" psql -U "${DB_USER}" -d "${DB_NAME}" -c "\
        SELECT schemaname, tablename, n_live_tup as row_count \
        FROM pg_stat_user_tables \
        ORDER BY n_live_tup DESC;" \
        > "${BACKUP_DIR}/database/table_stats.txt"
    
else
    error "Database container not running: ${DB_CONTAINER}"
    exit 1
fi

DB_END=$(date +%s)
DB_TIME=$((DB_END - DB_START))
log "Database backup completed in ${DB_TIME} seconds"

# 3. Backup configuration files
log "Backing up configuration files..."
CONFIG_START=$(date +%s)

# Backup docker-compose and related files
cp -r "/opt/${APP_NAME}"/*.yml "${BACKUP_DIR}/configs/" 2>/dev/null || true
cp -r "/opt/${APP_NAME}"/.env "${BACKUP_DIR}/configs/" 2>/dev/null || true
cp -r "/opt/${APP_NAME}"/docker-compose.yml "${BACKUP_DIR}/configs/" 2>/dev/null || true

# Backup init.sql
cp "/opt/${APP_NAME}"/init.sql "${BACKUP_DIR}/configs/" 2>/dev/null || true

# Save Docker images info
docker images --format "{{.Repository}}:{{.Tag}}" | grep "${APP_NAME}" > "${BACKUP_DIR}/configs/docker_images.txt" || true

CONFIG_END=$(date +%s)
CONFIG_TIME=$((CONFIG_END - CONFIG_START))
log "Configuration backup completed in ${CONFIG_TIME} seconds"

# 4. Create backup metadata
log "Creating backup metadata..."
cat > "${BACKUP_DIR}/backup_metadata.json" <<EOF
{
    "backup_timestamp": "${TIMESTAMP}",
    "app_name": "${APP_NAME}",
    "environment": "{{ env_name }}",
    "hostname": "$(hostname)",
    "backup_path": "${BACKUP_DIR}",
    "durations": {
        "volumes_seconds": ${VOLUME_TIME},
        "database_seconds": ${DB_TIME},
        "configs_seconds": ${CONFIG_TIME}
    },
    "sizes": {
        "total_bytes": $(du -sb "${BACKUP_DIR}" | cut -f1),
        "total_human": "$(du -sh "${BACKUP_DIR}" | cut -f1)"
    },
    "docker_info": {
        "compose_version": "$(docker-compose --version)",
        "docker_version": "$(docker --version)"
    }
}
EOF

# Calculate backup statistics
BACKUP_END=$(date +%s)
TOTAL_TIME=$((BACKUP_END - BACKUP_START))
BACKUP_SIZE=$(du -sh "${BACKUP_DIR}" | cut -f1)

# Create "latest" symlink
rm -f "${BACKUP_BASE}/latest"
ln -s "${BACKUP_DIR}" "${BACKUP_BASE}/latest"

# Save backup log
cat > "${BACKUP_DIR}/backup.log" <<EOF
Backup Summary
==============
Timestamp: ${TIMESTAMP}
Environment: {{ env_name }}
Host: $(hostname)
Total Duration: ${TOTAL_TIME} seconds
Total Size: ${BACKUP_SIZE}

Component Times:
- Volumes: ${VOLUME_TIME}s
- Database: ${DB_TIME}s
- Configs: ${CONFIG_TIME}s

Backup Location: ${BACKUP_DIR}
EOF

log "=========================================="
log "Backup completed successfully!"
log "Total time: ${TOTAL_TIME} seconds"
log "Total size: ${BACKUP_SIZE}"
log "Location: ${BACKUP_DIR}"
log "=========================================="

exit 0
